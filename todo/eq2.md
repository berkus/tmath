равенство
quot funext
множества subtype
prop
propext

em
berardi paradox
choice
diaconescu theorem

тактики
упражнения

---

# Равенство

Одно и то же число может быть записано по разному:

$$4 \qquad 100 \qquad \mathrm{IV} \qquad ||||$$

Другой пример: два различных представления одного и того же *вещественного* числа:

$$0.999\ldots \qquad 1$$

Карта не есть территория.

Что же является территорией в математике? Ответ может быть разным:

- Платонизм: некие сущности в мире идей
- Интуиционизм: представления в голове у идеализованного математика
- Формализм: территории нет, есть только символы

Можно также рассмотреть связь между символами и представлениями в голове у *реального* математика. Это соответствие неидеально — математик может считать, что некоторое утверждение истино (хотя не доказано), и затем вывести факт, что оно на самом деле ложно.

Но мы ожидаем, что то, что в символах, и то, что в голове постепенно сходится — математик корректирует свои представления по мере взаимодействия с символами, и в свою очередь меняет выраженные в символах предположения так, чтобы их следствия соответствовали желаемой картине.

Так или иначе, но хорошая карта сохраняет отношения между вещами — и мы можем рассматривать отношения как таковые как территорию.

Важнейшим из отношений является равенство. Интуитивно, мы можем описать его свойства так:

1. Любая вещь равна сама себе
2. Равные вещи неразличимы

Формально же, они соответствуют следующим постулатам:

$$\begin{aligned}
rfl &: ∀\{x:τ\}.\; x = x \\
ndrec &: ∀\{x:α\}\{M: α → \mathcal U\ i\}.\; M\ x → \{y: α\} → (x = y) → M\ y
\end{aligned}$$

$rfl$[^rfl] выражает первое свойство буквально. Но эта буквальность с точностью до вычислительного равенства, так как вычислительно равные типы неразличимы. Так, например, $2 + 2 = 4$ и $4 = 4$ это один и тот же тип — оба выражения вычисляются в $4 = 4$.

Соответствие между вторым свойством и $ndrec$[^ndrec] тоньше. Пусть $P$ это какое-то свойство, которому могут удовлетворять значения типа $τ$. Если значения $x\, y: τ$ равны, то свойство $P$ не может их различить: если $P\ x$ истинно, то и $P\ y$ должно быть истинно, и наоборот. $ndrec$ обобщает это рассуждение до любого типа: если $x = y$, то любому значению $M\ x$ соответствует некоторое значение $M\ y$.

В Lean, равенство это индуктивное семейство типов:

```lean
inductive Eq : α → α → Prop where
  | refl (a : α) : Eq a a
```

Соответствующий рекурсор отличается от $ndrec$ лишь тем, что $M$ также принимает тип равенства в качестве аргумента:

```
Eq.rec: {a: α} → {M: (b: α) → a = b → Sort u} →
  M a (_: a = a) → {b: α} → (e: a = b) → M b e
```

Докажем несколько простых теорем о равенстве. Сначала докажем, что если $x = y$, то и $y = x$:

```lean
--- Eq.symm
example {x y: α}(e: x = y): y = x :=
  Eq.ndrec (motive := λv => v = x) (rfl: x = x) e
```

Lean также позволяет записывать применение равенства как `e ▸ m`, с автоматическим выводом подходящего мотива:

```lean
example {x y: α}(e: x = y): y = x :=
  e ▸ (rfl: x = x)
```

Схожим образом доказываются и другие теоремы:

```lean
-- Eq.trans
example {x y z: α}(xy: x = y)(yz: y = z): x = z :=
  yz ▸ xy

-- Eq.congrArg
example {x y: α}{f: α → β}(e: x = y): f x = f y :=
  e ▸ (rfl: f x = f x)
```

Теперь покажем, как какие-либо два значения могут быть *не равны*. Конкретно, докажем, что $false ≠ true$.

Для многих индуктивных типов, Lean генерирует функцию `noConfusionType`, результатом которой являются тип $P$ или $P → P$ в зависимости от того, равны ли значения или нет. Для типа `Bool`
функция `noConfusion` определена следующим образом:

```lean
def Bool.noConfusionType (P: Sort u)(x:Bool)(y:Bool): Sort u :=
  x.casesOn (y.casesOn (P → P) P) (y.casesOn P (P → P))
```

Выражения `Bool.noConfusion P false false` и `Bool.noConfusion P true true` вычисляются в `P → P`, когда же выражения `Bool.noConfusion P false true` и `Bool.noConfusion P true false` вычисляются в `P`.

Мы можем доказать, что для любого `b:Bool` тип `Bool.noConfusion P b b` населён.

Для этого применяем рекурсор. Так как и `Bool.noConfusion P false false`, и `Bool.noConfusion P true true` вычислительно равны `P → P`, достаточно доказать лишь последнее.

```lean
theorem bool_d: ∀b, Bool.noConfusionType P b b :=
  Bool.rec id id
```

Функция `id` определена как `λx => x`.

Используя `bool_d`, доказываем абсурдность `false = true`:

```lean
example (h: false = true): False :=
  Eq.ndrec (bool_d false) h
```

Кроме `noConfusionType`, Lean также генерирует функцию `noConfusion`. Для `Bool` она определена так:

```lean
def Bool.noConfusion {P: Sort u}{x y : Bool}(xy: x = y): Bool.noConfusionType P x y :=
  Eq.ndrec (motive := λv => x = v → Bool.noConfusionType P x v)
    (λ(_: x = x) => x.casesOn (λa => a) (λa => a)) xy xy
```

С ней доказательство `false ≠ true` сводится к `Bool.noConfusion h`.

Мы можем различить значения типа `Bool` только благодаря разбору во вселенную типов — отображению булевого значения в тот или иной тип в зависимости от того, равен ли он `false` или `true`. Но не все типы являются индуктивными, и следовательно, не всегда два значения какого-то типа можно различить.

И здесь мы переходим к ещё одному свойству равенства: неразличимые вещи неотличимы от равных.

Lean применяет этот принцип к целой вселенной типов. Для любого индуктивного типа в `Prop`, он запрещает любой разбор во вселенную типов, который мог бы различить два значения этого типа.

Например, Lean не принимает следующий пример:

```lean
example (P Q: Prop)(pq: P ∨ Q): Prop := pq.rec (λ_ => False) (λ_ => True)
```

Таким образом, Lean делает невозможным доказательства того, что какие-то два значения любого типа в `Prop` различны.

Сделав невозможным доказательство неравенства, Lean объявляет все значения любого типа в `Prop` равными. То есть, для любого типа `P : Prop`, любые два значения `x y : P` *равны по определению*.

Так как типы в `Prop` соответствуют высказываниям, а из значения — доказательствам высказываний,
это свойство вселенной `Prop` означает, что доказательства одного и того же высказывания неразличимы — любое из них выражают одно и то же свидетельство истинности.

Неразличимость значений — не единственное отличие `Prop` от остальных вселенных типов.

Вспомним правило типизации для функций:

$$\frac{
  Γ ⊢ {\color{red}α}: \mathcal U\ i \qquad
  Γ,({\color{red}x}: {\color{red}α}) ⊢ {\color{red}β}: \mathcal U\ j
}{Γ ⊢ (∀{\color{red}x}:{\color{red}α}.\; {\color{red}β}): \mathcal U\ max(i,j)}$$

Оно используется во всех случаях, когда $j ⩾ 1$. Но в случае, когда ${\color{red}β}: \mathcal U\ 0$, Lean использует другое правило:

$$\frac{
  Γ ⊢ {\color{red}α}: \mathcal U\ i \qquad
  Γ,({\color{red}x}: {\color{red}α}) ⊢ {\color{red}β}: \mathcal U\ 0
}{Γ ⊢ (∀{\color{red}x}:{\color{red}α}.\; {\color{red}β}): \mathcal U\ 0}$$

То есть если ${\color{red}β}: \mathcal{Prop}$, то и $∀{\color{red}x}:{\color{red}α}.\; {\color{red}β}$ также имеет тип $\mathcal{Prop}$ — вне зависимости от того, какой вселенной типов принадлежит ${\color{red}α}$.

Это свойство `Prop` называется непредикативностью, и оно позволяет высказываниям оставаться внутри `Prop`.

Зачем уравнивать значения типов в целой вселенной типов? Причина связана с тем, как высказывания и доказтельства используются на практике.

Пусть $P: α → \mathcal{Prop}$ — некоторое свойство. Мы можем рассмотреть такие значения типа $α$, для которых выполняется свойство $P$. Этим значениям можно сопоставить следующий тип:

```lean
structure Subtype {α: Sort u}(P: α → Prop) where
  val: α
  property: P val
```

Тип `Subtype P` называется подтипом типа `α` по свойству `P`. Он также обозначается как `{x // P x}` в Lean.

Для отбора значений типа `α` по свойству `P`, нам важно лишь то, существует ли доказательство `P x` для конкретных значений `x:α`. Наличие же различных доказательств высказывания `P x` для какого-то конкретного `x:α` напротив, представляло бы проблему, так как каждому доказательству соответствовало бы отдельное значение подтипа.

Рассмотрим пример. Пусть `fls` — функция из натуральных чисел в булевые значения, результатом которой всегда является `false`:

```lean
def fls (_:Nat): Bool := false
```

Рассмотрим образ функции `fls`: такие значения типа `Bool`, что для каждого из них существует такое натуральное число `n`, что `fls n = b`. Иначе говоря, нас интересуют все возможные значения `fls n` для произвольных `n`.

Соответствующим образу $fls$ подтипом является `{b:Bool // ∃n, fls n = b}`. Очевидно, что значение `false` принадлежит образу:

```lean
#check (⟨false, ⟨0, rfl⟩⟩ : {b:Bool // ∃n, fls n = b})
```

Хотя единственным возможным значением в образе может быть `false`, ему соответствуют различные доказательствао `∃n, fls n = false`. Например, вот значение с другим доказательством этого высказывания:

```lean
#check (⟨false, ⟨1, rfl⟩⟩ : {b:Bool // ∃n, fls n = b})
```

Здесь неразличимость доказательств оказывается кстати. Хотя доказать `∃n, fls n = false` можно по-разному, все докатетельства выражают одно и тоже свидетельство истинности. И оба значения подтипа оказываются равны:

```lean
#check
  let I := {b:Bool // ∃n, fls n = b}
  let z:I := ⟨false, ⟨0, rfl⟩⟩
  let s:I := ⟨false, ⟨1, rfl⟩⟩
  (rfl : z = s)
```

Можно также доказать, что `⟨false, _⟩` это единственное значение типа `{b:Bool // ∃n, fls n = b}`:

```lean
example (x: {b:Bool // ∃n, fls n = b}): x = ⟨false, ⟨0, rfl⟩⟩ :=
  x.recOn
    λb => b.recOn (λ_ => rfl) (λ⟨_, (e: false = true)⟩ => Bool.noConfusion e)
```

Таким образом, благодаря неразличимости доказательств, тип `{b:Bool // ∃n, fls n = b}` соответствует интуитивному представлению о том, что такое образ функции.

Внешне, подтипы похожи на подмножества в теории множеств. Механика их, однако, значительно различается.

Теория множеств основана на логике первого порядка. В этой формальной системе нет вычислимых функций. Как следствие, нет и доказательств как выражений: доказательством является вывод заключения из предпосылок с помощью правил вывода. Более того, высказывания также не являются значениями.

Для рассуждения о чём-либо, логика первого порядка расширяется набором отношений между какими-то значениями и набором аксиом. В теории множеств, единственными отношениями являются $(=)$ и $(∈)$.

$$∀\bar w.\; ∀A.\; ∃B.\; ∀x.\; x ∈ B \leftrightarrow (x ∈ A ∧ P(\bar w, A, x))$$

$P: α → \mathcal{Prop} \quad \{x ∈ α \mid P(x)\}$

$$\begin{aligned}
&x ∈ A &\qquad & A\ x\\
&A ⊆ B  &  &∀x.\; A\ x → B\ x\\
&∅  &  &λx.\; False \\
&\{a\}  &  &λx.\; x = a  \\
&A ∪ B  &  &λx.\; A\ x ∨ B\ x \\
&A ∩ B  &  &λx.\; A\ x ∧ B\ x \\
&A \setminus B  &  &λx.\; A\ x ∧ ¬(B\ x)  \\
&A^\complement  &  &λx.\; ¬(A\ x)
\end{aligned}$$

$$(∀x\,y\,z.\;F\ x\ y → F\ x\ z → y = z) ∧ (∀x.\;∃y.\; F\ x\ y)$$

$$Quot : \{α: \mathcal U\ i\} → (α → α → \mathcal{Prop}) → \mathcal U\ i$$

$$\begin{aligned}
mk &: (R: α → α → \mathcal{Prop}) → α → Quot\ R \\
lift &: (f: α → β) → (∀x\, y.\; R\ x\ y → f\ x = f\ y) → (Quot\ R → β) \\
ind &: (∀x.\; P\ (mk\ R\ x)) → ∀(q: Quot\ R).\; P\ q
\end{aligned}$$

$$sound : ∀\{x\,y\}.\; R\ x\ y → (mk\ R\ x) = (mk\ R\ y)$$

```lean
example {α: Sort u}{β: α → Sort v}{f g: (x:α) → β x}(h: ∀x, f x = g x): f = g :=
  let r := λf g => ∀x, f x = g x
  let qApp (f: Quot r): (x:α) → β x :=
    λx => (f.liftOn (λf => f x) (λf g (h: ∀x, f x = g x) => h x) : β x)
  congrArg qApp (Quot.sound h : Quot.mk _ f = Quot.mk _ g)
```

$$propext: ∀\{P\, Q: \mathcal{Prop}\}.\; (P ↔ Q) → P = Q$$

---

[^rfl]: От англ. reflexivity, рефлексивность

[^ndrec]: Англ. non-dependent recursor
